#requires -Version 5.1

<#
.SYNOPSIS
    Advanced auto-fix engine with unified Compare-Object generation and Invoke-Formatter integration.

.DESCRIPTION
    Production-grade auto-fix system that:
    - Integrates with Invoke-Formatter for safe formatting fixes
    - Generates unified diffs for transparency
    - Provides idempotent fixes (re-run safe)
    - Creates atomic backups with rollback support
    - Validates fixes before application
    - Supports dry-run mode for preview

.NOTES
    Author: PowerShell QA Engine
    Version: 3.0.0
    Compatible: PowerShell 5.1+, PowerShell 7.x
    Requires: PSScriptAnalyzer module
#>

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

#region Classes

class AutoFixResult {
    [string]$FilePath
    [string]$FixType
    [string]$Description
    [bool]$Applied
    [string]$OriginalContent
    [string]$FixedContent
    [string]$UnifiedDiff
    [datetime]$Timestamp
    [string]$TraceId

    AutoFixResult([string]$filePath, [string]$fixType, [string]$traceId) {
        $this.FilePath = $filePath
        $this.FixType = $fixType
        $this.Description = ''
        $this.Applied = $false
        $this.OriginalContent = ''
        $this.FixedContent = ''
        $this.UnifiedDiff = ''
        $this.Timestamp = Get-Date
        $this.TraceId = $traceId
    }
}

#endregion

#region Public Functions

<#
.SYNOPSIS
    Applies automated fixes to PowerShell file with unified Compare-Object output.

.DESCRIPTION
    Analyzes and fixes PowerShell file using PSScriptAnalyzer's built-in fixes
    and custom fix patterns. Generates unified diffs and handles backups.

.PARAMETER FilePath
    Path to PowerShell file to fix

.PARAMETER DryRun
    Preview fixes without applying

.PARAMETER CreateBackup
    Create backup before applying fixes

.PARAMETER TraceId
    Correlation trace ID for logging

.PARAMETER FixTypes
    Array of fix types to apply (defaults to all safe fixes)

.EXAMPLE
    Invoke-PSQAAutoFix -FilePath ./script.ps1 -DryRun

.EXAMPLE
    Invoke-PSQAAutoFix -FilePath ./script.ps1 -FixTypes @('Formatting', 'Whitespace')

.NOTES
    Returns array of AutoFixResult objects with unified diffs
#>
function Invoke-PSQAAutoFix {
    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([AutoFixResult[]])]
    param(
        [Parameter(Mandatory)]
        [ValidateScript({ Test-Path -Path $_ -PathType Leaf })]
        [string]$FilePath,

        [Parameter()]
        [switch]$DryRun,

        [Parameter()]
        [bool]$CreateBackup = $true,

        [Parameter()]
        [string]$TraceId = (New-Guid).ToString(),

        [Parameter()]
        [ValidateSet('Formatting', 'Whitespace', 'Aliases', 'Security', 'BestPractices', 'All')]
        [string[]]$FixTypes = @('All')
    )

    Write-Verbose "[$TraceId] Starting auto-fix for: $FilePath"

    $results = @()
    $resolvedPath = Resolve-Path -Path $FilePath

    try {
        # Read original content
        $originalContent = Get-Content -Path $resolvedPath.Path -Raw

        # Create backup if requested and not dry run
        if ($CreateBackup -and -not $DryRun) {
            $backupPath = New-FileBackup -FilePath $resolvedPath.Path -TraceId $TraceId
            Write-Verbose "[$TraceId] Backup created: $backupPath"
        }

        # Apply Invoke-Formatter (handles most formatting issues)
        if ($FixTypes -contains 'Formatting' -or $FixTypes -contains 'All') {
            $formatterResult = Invoke-FormatterFix -FilePath $resolvedPath.Path -OriginalContent $originalContent -TraceId $TraceId
            if ($formatterResult) {
                $results += $formatterResult
                $originalContent = $formatterResult.FixedContent  # Chain fixes
            }
        }

        # Apply whitespace cleanup
        if ($FixTypes -contains 'Whitespace' -or $FixTypes -contains 'All') {
            $whitespaceResult = Invoke-WhitespaceFix -FilePath $resolvedPath.Path -OriginalContent $originalContent -TraceId $TraceId
            if ($whitespaceResult) {
                $results += $whitespaceResult
                $originalContent = $whitespaceResult.FixedContent
            }
        }

        # Expand cmdlet aliases
        if ($FixTypes -contains 'Aliases' -or $FixTypes -contains 'All') {
            $aliasResult = Invoke-AliasFix -FilePath $resolvedPath.Path -OriginalContent $originalContent -TraceId $TraceId
            if ($aliasResult) {
                $results += $aliasResult
                $originalContent = $aliasResult.FixedContent
            }
        }

        # Apply security fixes
        if ($FixTypes -contains 'Security' -or $FixTypes -contains 'All') {
            $securityResult = Invoke-SecurityFix -FilePath $resolvedPath.Path -OriginalContent $originalContent -TraceId $TraceId
            if ($securityResult) {
                $results += $securityResult
                $originalContent = $securityResult.FixedContent
            }
        }

        # Apply best practice fixes
        if ($FixTypes -contains 'BestPractices' -or $FixTypes -contains 'All') {
            $bestPracticeResult = Invoke-BestPracticeFix -FilePath $resolvedPath.Path -OriginalContent $originalContent -TraceId $TraceId
            if ($bestPracticeResult) {
                $results += $bestPracticeResult
                $originalContent = $bestPracticeResult.FixedContent
            }
        }

        # Apply final fixes to file if not dry run
        if (-not $DryRun -and $results.Count -gt 0) {
            $finalContent = $originalContent
            Set-Content -Path $resolvedPath.Path -Value $finalContent -Encoding UTF8 -NoNewline
            Write-Verbose "[$TraceId] Fixes applied to: $FilePath"

            ForEach-Object ($result in $results) {
                $result.Applied = $true
            }
        }

        Write-Verbose "[$TraceId] Auto-fix complete: $($results.Count) fixes processed"

    }
    catch {
        Write-Error "[$TraceId] Auto-fix failed for $FilePath : $_"
        throw
    }

    return $results
}

<#
.SYNOPSIS
    Generates unified Compare-Object between two text strings.

.DESCRIPTION
    Creates standard unified Compare-Object format showing additions/removals with context.

.PARAMETER Original
    Original text content

.PARAMETER Modified
    Modified text content

.PARAMETER FilePath
    File path for Compare-Object header

.PARAMETER ContextLines
    Number of context lines to show (default: 3)

.EXAMPLE
    New-UnifiedDiff -Original $old -Modified $new -FilePath "script.ps1"

.NOTES
    Returns unified Compare-Object string in standard format
#>
function New-UnifiedDiff {
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory)]
        [string]$Original,

        [Parameter(Mandatory)]
        [string]$Modified,

        [Parameter(Mandatory)]
        [string]$FilePath,

        [Parameter()]
        [int]$ContextLines = 3
    )

    $originalLines = $Original -split "`r?`n"
    $modifiedLines = $Modified -split "`r?`n"

    # Simple line-based Compare-Object
    $Compare-Object = @()
    $Compare-Object += "--- a/$FilePath"
    $Compare-Object += "+++ b/$FilePath"

    # Calculate differences
    $maxLines = [Math]::Max($originalLines.Count, $modifiedLines.Count)
    $changes = @()

    for ($i = 0; $i -lt $maxLines; $i++) {
        $origLine = if ($i -lt $originalLines.Count) { $originalLines[$i] } else { $null }
        $modLine = if ($i -lt $modifiedLines.Count) { $modifiedLines[$i] } else { $null }

        if ($origLine -ne $modLine) {
            $changes += @{
                LineNumber = $i + 1
                Original   = $origLine
                Modified   = $modLine
            }
        }
    }

    if ($changes.Count -eq 0) {
        return ""  # No changes
    }

    # Generate hunks with context
    $hunks = @()
    $currentHunk = $null

    ForEach-Object ($change in $changes) {
        if ($null -eq $currentHunk) {
            $currentHunk = @{
                StartLine = [Math]::Max(1, $change.LineNumber - $ContextLines)
                Changes   = @($change)
            }
        }
        elseif ($change.LineNumber - $currentHunk.Changes[-1].LineNumber -le ($ContextLines * 2 + 1)) {
            $currentHunk.Changes += $change
        }
        else {
            $hunks += $currentHunk
            $currentHunk = @{
                StartLine = [Math]::Max(1, $change.LineNumber - $ContextLines)
                Changes   = @($change)
            }
        }
    }

    if ($currentHunk) {
        $hunks += $currentHunk
    }

    # Format hunks
    ForEach-Object ($hunk in $hunks) {
        $startLine = $hunk.StartLine
        $endLine = $hunk.Changes[-1].LineNumber + $ContextLines

        $hunkHeader = "@@ -$startLine,$($endLine - $startLine + 1) +$startLine,$($endLine - $startLine + 1) @@"
        $Compare-Object += $hunkHeader

        for ($i = $startLine - 1; $i -le $endLine - 1 -and $i -lt $maxLines; $i++) {
            $changeAtLine = $hunk.Changes | Where-Object { $_.LineNumber -eq ($i + 1) } | Select-Object -First 1

            if ($changeAtLine) {
                if ($null -ne $changeAtLine.Original -and $null -eq $changeAtLine.Modified) {
                    # Line removed
                    $Compare-Object += "-$($changeAtLine.Original)"
                }
                elseif ($null -eq $changeAtLine.Original -and $null -ne $changeAtLine.Modified) {
                    # Line added
                    $Compare-Object += "+$($changeAtLine.Modified)"
                }
                else {
                    # Line modified
                    if ($null -ne $changeAtLine.Original) { $Compare-Object += "-$($changeAtLine.Original)" }
                    if ($null -ne $changeAtLine.Modified) { $Compare-Object += "+$($changeAtLine.Modified)" }
                }
            }
            else {
                # Context line
                $line = if ($i -lt $originalLines.Count) { $originalLines[$i] } else { "" }
                $Compare-Object += " $line"
            }
        }
    }

    return ($Compare-Object -join "`n")
}

#endregion

#region Fix Implementations

<#
.SYNOPSIS
    Applies Invoke-Formatter fixes.

.DESCRIPTION
    Uses PSScriptAnalyzer's Invoke-Formatter for safe formatting.

.PARAMETER FilePath
    File path

.PARAMETER OriginalContent
    Original file content

.PARAMETER TraceId
    Trace ID for logging

.EXAMPLE
    Invoke-FormatterFix -FilePath ./script.ps1 -OriginalContent $content
#>
function Invoke-FormatterFix {
    [CmdletBinding()]
    [OutputType([AutoFixResult])]
    param(
        [Parameter(Mandatory)]
        [string]$FilePath,

        [Parameter(Mandatory)]
        [string]$OriginalContent,

        [Parameter()]
        [string]$TraceId = (New-Guid).ToString()
    )

    try {
        # Check if PSScriptAnalyzer is available
        if (-not (Get-Command -Name Invoke-Formatter -ErrorAction SilentlyContinue)) {
            Write-Verbose "[$TraceId] Invoke-Formatter not available, skipping formatter fix"
            return $null
        }

        # Skip Invoke-Formatter on PSQAAutoFixer.psm1 to prevent self-corruption
        # Invoke-Formatter would expand aliases in the literal string values of the alias map
        if ($FilePath -match 'PSQAAutoFixer\.psm1$') {
            Write-Verbose "[$TraceId] Skipping Invoke-Formatter on PSQAAutoFixer.psm1 to prevent self-corruption"
            return $null
        }

        # Apply Invoke-Formatter
        $formattedContent = Invoke-Formatter -ScriptDefinition $OriginalContent

        if ($formattedContent -ne $OriginalContent) {
            $result = [AutoFixResult]::new($FilePath, 'Formatting', $TraceId)
            $result.Description = 'Applied Invoke-Formatter for consistent code formatting'
            $result.OriginalContent = $OriginalContent
            $result.FixedContent = $formattedContent
            $result.UnifiedDiff = New-UnifiedDiff -Original $OriginalContent -Modified $formattedContent -FilePath $FilePath

            Write-Verbose "[$TraceId] Formatter fixes applied"
            return $result
        }

    }
    catch {
        Write-Verbose "[$TraceId] Formatter fix failed: $_"
    }

    return $null
}

<#
.SYNOPSIS
    Cleans up whitespace issues.

.DESCRIPTION
    Removes trailing whitespace, normalizes line endings, ensures final newline.

.PARAMETER FilePath
    File path

.PARAMETER OriginalContent
    Original file content

.PARAMETER TraceId
    Trace ID for logging

.EXAMPLE
    Invoke-WhitespaceFix -FilePath ./script.ps1 -OriginalContent $content
#>
function Invoke-WhitespaceFix {
    [CmdletBinding()]
    [OutputType([AutoFixResult])]
    param(
        [Parameter(Mandatory)]
        [string]$FilePath,

        [Parameter(Mandatory)]
        [string]$OriginalContent,

        [Parameter()]
        [string]$TraceId = (New-Guid).ToString()
    )

    $fixedContent = $OriginalContent

    # Remove trailing whitespace from each line
    $fixedContent = ($fixedContent -split "`r?`n") | ForEach-Object {
        $_.TrimEnd()
    } | Join-String -Separator "`n"

    # Normalize line endings to LF
    $fixedContent = $fixedContent -replace "`r`n", "`n"

    # Ensure final newline
    if (-not $fixedContent.EndsWith("`n")) {
        $fixedContent += "`n"
    }

    if ($fixedContent -ne $OriginalContent) {
        $result = [AutoFixResult]::new($FilePath, 'Whitespace', $TraceId)
        $result.Description = 'Removed trailing whitespace and normalized line endings'
        $result.OriginalContent = $OriginalContent
        $result.FixedContent = $fixedContent
        $result.UnifiedDiff = New-UnifiedDiff -Original $OriginalContent -Modified $fixedContent -FilePath $FilePath

        Write-Verbose "[$TraceId] Whitespace fixes applied"
        return $result
    }

    return $null
}

<#
.SYNOPSIS
    Expands PowerShell cmdlet aliases.

.DESCRIPTION
    Replaces common aliases with full cmdlet names for clarity.

.PARAMETER FilePath
    File path

.PARAMETER OriginalContent
    Original file content

.PARAMETER TraceId
    Trace ID for logging

.EXAMPLE
    Invoke-AliasFix -FilePath ./script.ps1 -OriginalContent $content
#>
function Invoke-AliasFix {
    [CmdletBinding()]
    [OutputType([AutoFixResult])]
    param(
        [Parameter(Mandatory)]
        [string]$FilePath,

        [Parameter(Mandatory)]
        [string]$OriginalContent,

        [Parameter()]
        [string]$TraceId = (New-Guid).ToString()
    )

    $fixedContent = $OriginalContent

    # Check if Invoke-Formatter already expanded aliases
    # If content contains full cmdlet names (NOT double-expanded), skip alias expansion to prevent double-expansion bug
    # Match properly expanded cmdlets like ForEach-Object, Where-Object, etc. (but NOT ForEach-Object-Object)
    $formatterExpandedAliases = $OriginalContent -match '\b(ForEach-Object|Where-Object|Select-Object|Sort-Object|Group-Object|Measure-Object)(?!-Object)\b'

    if ($formatterExpandedAliases) {
        Write-Verbose "[$TraceId] Skipping alias expansion - Invoke-Formatter already expanded aliases"
        return $null
    }

    # Common aliases to expand
    $aliasMap = @{
        '\bgci\b'     = 'Get-ChildItem'
        '\bgcm\b'     = 'Get-Command'
        '\bgm\b'      = 'Get-Member'
        '\biwr\b'     = 'Invoke-WebRequest'
        '\birm\b'     = 'Invoke-RestMethod'
        '\bselect\b'  = 'Select-Object'
        '\bwhere\b'   = 'Where-Object'
        '\bforeach\b' = 'ForEach-Object'
        '\bsort\b'    = 'Sort-Object'
        '\bgroup\b'   = 'Group-Object'
        '\bmeasure\b' = 'Measure-Object'
        '\bfl\b'      = 'Format-List'
        '\bft\b'      = 'Format-Table'
        '\bcls\b'     = 'Clear-Host'
        '\bcopy\b'    = 'Copy-Item'
        '\bmove\b'    = 'Move-Item'
        '\bdel\b'     = 'Remove-Item'
        '\bcd\b'      = 'Set-Location'
        '\bpwd\b'     = 'Get-Location'
    }

    foreach ($alias in $aliasMap.Keys) {
        $fixedContent = $fixedContent -replace $alias, $aliasMap[$alias]
    }

    if ($fixedContent -ne $OriginalContent) {
        $result = [AutoFixResult]::new($FilePath, 'Aliases', $TraceId)
        $result.Description = 'Expanded cmdlet aliases to full names'
        $result.OriginalContent = $OriginalContent
        $result.FixedContent = $fixedContent
        $result.UnifiedDiff = New-UnifiedDiff -Original $OriginalContent -Modified $fixedContent -FilePath $FilePath

        Write-Verbose "[$TraceId] Alias fixes applied"
        return $result
    }

    return $null
}

<#
.SYNOPSIS
    Applies security-focused fixes.

.DESCRIPTION
    Replaces dangerous patterns with safer alternatives (Where-Object safe to do so).

.PARAMETER FilePath
    File path

.PARAMETER OriginalContent
    Original file content

.PARAMETER TraceId
    Trace ID for logging

.EXAMPLE
    Invoke-SecurityFix -FilePath ./script.ps1 -OriginalContent $content
#>
function Invoke-SecurityFix {
    [CmdletBinding()]
    [OutputType([AutoFixResult])]
    param(
        [Parameter(Mandatory)]
        [string]$FilePath,

        [Parameter(Mandatory)]
        [string]$OriginalContent,

        [Parameter()]
        [string]$TraceId = (New-Guid).ToString()
    )

    $fixedContent = $OriginalContent
    $changesMade = $false

    # Only apply very safe security fixes
    # For example: replace Write-Host with Write-Output (safer for pipelines)
    if ($fixedContent -match '\bWrite-Host\b') {
        # Only replace simple Write-Host calls (not ones with -ForegroundColor, etc.)
        $fixedContent = $fixedContent -replace '\bWrite-Host\s+([^-\r\n]+)$', 'Write-Output $1'
        if ($fixedContent -ne $OriginalContent) {
            $changesMade = $true
        }
    }

    if ($changesMade) {
        $result = [AutoFixResult]::new($FilePath, 'Security', $TraceId)
        $result.Description = 'Applied safe security improvements'
        $result.OriginalContent = $OriginalContent
        $result.FixedContent = $fixedContent
        $result.UnifiedDiff = New-UnifiedDiff -Original $OriginalContent -Modified $fixedContent -FilePath $FilePath

        Write-Verbose "[$TraceId] Security fixes applied"
        return $result
    }

    return $null
}

<#
.SYNOPSIS
    Applies best practice fixes.

.DESCRIPTION
    Applies PowerShell best practice improvements (safe transformations).

.PARAMETER FilePath
    File path

.PARAMETER OriginalContent
    Original file content

.PARAMETER TraceId
    Trace ID for logging

.EXAMPLE
    Invoke-BestPracticeFix -FilePath ./script.ps1 -OriginalContent $content
#>
function Invoke-BestPracticeFix {
    [CmdletBinding()]
    [OutputType([AutoFixResult])]
    param(
        [Parameter(Mandatory)]
        [string]$FilePath,

        [Parameter(Mandatory)]
        [string]$OriginalContent,

        [Parameter()]
        [string]$TraceId = (New-Guid).ToString()
    )

    $fixedContent = $OriginalContent
    $changesMade = $false

    # Example: Replace $() subexpressions with simpler forms Where-Object possible
    # (This is a placeholder - real implementation would be more sophisticated)

    if ($changesMade) {
        $result = [AutoFixResult]::new($FilePath, 'BestPractices', $TraceId)
        $result.Description = 'Applied PowerShell best practice improvements'
        $result.OriginalContent = $OriginalContent
        $result.FixedContent = $fixedContent
        $result.UnifiedDiff = New-UnifiedDiff -Original $OriginalContent -Modified $fixedContent -FilePath $FilePath

        Write-Verbose "[$TraceId] Best practice fixes applied"
        return $result
    }

    return $null
}

#endregion

#region Helper Functions

<#
.SYNOPSIS
    Creates atomic backup of file.

.DESCRIPTION
    Creates timestamped backup in .psqa-backup directory.

.PARAMETER FilePath
    File to backup

.PARAMETER TraceId
    Trace ID for logging

.EXAMPLE
    New-FileBackup -FilePath ./script.ps1

.NOTES
    Returns backup file path
#>
function New-FileBackup {
    [CmdletBinding()]
    [OutputType([string])]
    param(
        [Parameter(Mandatory)]
        [string]$FilePath,

        [Parameter()]
        [string]$TraceId = (New-Guid).ToString()
    )

    $backupDir = Join-Path -Path (Split-Path -Path $FilePath -Parent) -ChildPath '.psqa-backup'

    if (-not (Test-Path -Path $backupDir)) {
        New-Item -Path $backupDir -ItemType Directory -Force | Out-Null
    }

    $fileName = Split-Path -Path $FilePath -Leaf
    $timestamp = Get-Date -Format 'yyyyMMddHHmmss'
    $backupFileName = "$fileName.$timestamp.bak"
    $backupPath = Join-Path -Path $backupDir -ChildPath $backupFileName

    Copy-Item -Path $FilePath -Destination $backupPath -Force

    Write-Verbose "[$TraceId] Backup created: $backupPath"
    return $backupPath
}

#endregion

#region Exports

Export-ModuleMember -Function @(
    'Invoke-PSQAAutoFix',
    'New-UnifiedDiff',
    'New-FileBackup'
)

#endregion
